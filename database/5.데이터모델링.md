# 목차

- [목차](#목차)
- [1. Cardinality](#1-cardinality)
- [2. join 방식](#2-join-방식)
- [3. 정규화](#3-정규화)
  - [3.1. 정규화의 대상](#31-정규화의-대상)
  - [3.2. 정규화 종류](#32-정규화-종류)
    - [3.2.1. 제 1 정규화](#321-제-1-정규화)
    - [3.2.2. 제 2 정규화](#322-제-2-정규화)
    - [3.2.3. 제 3 정규화](#323-제-3-정규화)

# 1. Cardinality

RDBMS는 집합과 밀접한 관계가 있다. cardinality는 집합의 크기를 말한다.  

- 중복도가 낮다
  - 집합의 크기가 크다
    - 카디널리티가 높다
- 중복도가 높다
  - 집합의 크기가 작다
    - 카디널리티가 낮다

검색 성능에 영향을 줄 수 밖에 없다.

# 2. join 방식

# 3. 정규화

정규화는 논리적 데이터 모델을 일관성이 있고 중복을 제거하여 안정성을 가진 자료구조를 만들기 위한 것을 일컫는다.  

정규화의 목적은 다음과 같다.  

- 중복 값이 줄어듬
- NULL이 줄어듬
- 복잡한 코드로 데이터 모델을 보완할 필요가 없음
- 구조 확장 시 디자인 최소화

## 3.1. 정규화의 대상

- OLTP(`O`n`l`ine `T`ransaction `P`rocessiong)
  - CRUD가 자주 발생하는 부분은 정규화를 하는 것이 좋음
- OLAP(`O`n`l`ine `A`nalytical `P`rocessiong)
  - 대량으로 정보를 취합하는 것이 필요한 경우 반정규화

## 3.2. 정규화 종류

- 제 1 정규화(First Normal Form, 1NF)
- 제 2 정규화(Second Normal Form, 2NF)
- 제 3 정규화(Third Normal Form, 3NF)

### 3.2.1. 제 1 정규화

제 1정규화는 다음을 만족하여야 한다.  

1. 모든 속성은 반드시 단 하나의 값을 가져야 한다.
   1.  모든 domain이 원자 값(atomic value)로 구성됨
2. 모든 속성은 반복되는 형식이 나타나선 안된다.
3. 레코드는 상호 식별 가능해야한다.
   1. 기본 키로 찍어서 하나 식별 가능하냐

(1) 1번 위반 사례

|student_id|name|phone|
|-|-|-|
|1|Chiho Won|02-1234-4567, 010-1234-5678|
|2|Ed Sheeran|02-4321-5432, 010-1111-5678|
|3|Desiigner|031-1234-5678|

하나 이상의 값을 가지고 있는 속성이 존재한다. 따라서 phone 속성은 atomic하지 않게되었으므로 위반한 사례.  

(2) 2번 위반 사례

|student_id|name|phone1|phone2|
|-|-|-|-|
|1|Chiho Won|02-1234-4567|010-1234-5678|
|2|Ed Sheeran|02-4321-5432|010-1111-5678|
|3|Desiigner|031-1234-5678|null|

1번을 해결하면서 2번을 위반한 사례. phone이라는 속성이 두 개 등장하였다.  

(3) 3번 위반 사례

|student_id|name|phone|
|-|-|-|
|1|Chiho Won|02-1234-4567|
|1|Chiho Won|010-1234-5678|
|2|Ed Sheeran|02-4321-5432|
|2|Ed Sheeran|010-1111-5678|
|3|Desiigner|031-1234-5678|

2번을 해결했더니 3번을 위반했다. 레코드 상호 식별성이 날아갔다. 정신 나갈거 같아.  

이 모두를 해결하려면 다음과 같다.  

학생 테이블
|student_id|name|
|-|-|
|1|Chiho Won|
|2|Ed Sheeran|
|3|Desiigner|

전화번호부 테이블
|phone_id|student_id|phone|
|-|-|-|
|1|1|02-1234-4567|
|2|1|010-1234-5678|
|3|2|02-4321-5432|
|4|2|010-1111-5678|
|5|3|031-1234-5678|

학생 테이블과 전화번호부 테이블이 1:N(One to Many) 관계가 되었다.  

### 3.2.2. 제 2 정규화

제 2정규화는 다음을 만족하여야 한다.  

1. 식별자가 아닌 모든 속성들은 식별자 전체 속성에 완전 종속되어야 한다.
2. 이것을 물리 데이터 모델의 테이블로 말하면 기본키가 아닌 모든 칼럼들이 기본키에 종속적이어 야 2 차 정규형을 만족할 수 있다는 것이다.

|#학번|#코스코드|평가코드|평가내역|코스명|기간|
|-|-|-|-|-|-|
|1|10|1q2w3e4r|뭔가데이터|뭔가과목이름|뭔가데이터값|

식별자가 `학번`과 `코스코드`라고 가정할 때 위반사항은 다음과 같다.  

- 부분 종속

여기서 정리해야 할 용어

1. 함수 종속: X가 정해지면 Y도 정해지는 관계. X -> Y로 표현하고 Y는 X의 함수적 종속이라 부름. 여기서 X는 결정자, Y는 종속자.
2. 결정자가 여러 개인 경우 모든 결정자에 의해 종속자가 결정되면 `완전 함수 종속`이라고 부른다. 하지만 이 중 일부 결정자에 의해서만 종속자가 결정되면 `부분 함수 종속`이라고 부른다.  

그래서 결론은 `제 2정규화`는 `부분 함수 종속`을 못참겠다고 하는 친구다.  이를 위해 제 2정규화를 시키면 다음과 같다.  

**학과등록 테이블**  

|#학번|평가코드|평가내역|코스코드(FK)|
|-|-|-|-|
|학번같은거|평가코드같은거|내역같은거|코스코드FK같은거|

**코스 테이블**

|#코스코드|코스이름|기간|
|-|-|-|
|123|코스이름이란다|기간이란다|

### 3.2.3. 제 3 정규화

제 3정규화는 다음을 만족하여야 한다.  

책 내용

1. 2 차 정규형을 만족하고 식별자를 제외한 나머지 속성들 간의 종속이 존재하면 안된다.  

정리하면

1. 제 2차 정규형을 만족하는 릴레이션
2. 기본 키(pk)가 아닌 속성은 기본 키에만 의존함

그래서 만족하는 테이블을 만들자면  

**학과등록 테이블**  

|#학번|코스코드(FK)|평가코드(FK)|
|-|-|-|-|
|12341234|코스코드FK같은거|평가코드FK같은거|

**코스 테이블**

|#코스코드|코스이름|기간|
|-|-|-|
|123|코스이름이란다|기간이란다|

**평가 테이블**

|평가코드|평가내역|
|-|-|
|1234|F|

