# 목차

- [목차](#목차)
- [1. Java NIO](#1-java-nio)
  - [1.1. IO vs NIO](#11-io-vs-nio)
    - [1.1.1. Stream vs Channel](#111-stream-vs-channel)
    - [1.1.2. non-buffer vs buffer](#112-non-buffer-vs-buffer)
    - [1.1.3. blocking vs non-blocking](#113-blocking-vs-non-blocking)
  - [1.2. 무엇을 선택해야 하는가](#12-무엇을-선택해야-하는가)

# 1. Java NIO

자바 New IO. 자바4부터 출발한 nio 패키지에서 자바7 NIO 2 API가 추가 되면서 비동기 채널, 네트워크 등의 기능이 강화되었다.  

## 1.1. IO vs NIO

IO와 NIO 모두 IO라는 목적을 가지고 있지만 차이점은 방식에 있다.  

|구분|IO|NIO|
|-|-|-|
|입출력 방식|stream|channel|
|버퍼 방식|non-buffer|buffer|
|비동기|미지원|지원|
|블로킹/논블로킹|블로킹|모두 지원|

### 1.1.1. Stream vs Channel

스트림은 방향이 존재하고 입출력이 구분되어 있기 때문에 읽기 위해선 입력 스트림을 생성하고 쓰기 위해선 출력 스트림을 생성해야 한다.  

채널은 양방향 입출력이 가능하다. 따라서 입출력을 별도로 구분하여 생성할 필요가 없다.  

파일을 쓰려면 파일채널(FileChannel)만 생성하면 됨다.  

### 1.1.2. non-buffer vs buffer

IO는 보조 스트림 Buffered-를 사용해야 버퍼를 사용할 수 있다. NIO는 기본적으로 버퍼를 사용한 입출력을 하기 때문에 IO보다 입출력 성능이 좋다.  

### 1.1.3. blocking vs non-blocking

IO는 블로킹이 발생한다. 입력 스트림의 read() 메소드가 호출되면 데이터가 들어올 때 까지 스레드가 블로킹된다. write() 또한 마찬가지로 데이터를 쓰기 전까지 블로킹 된다.  

IO 스레드는 블로킹 되면 아무고토 모탐. 인터럽트도 불가능 'ㅁ' 유일한 방법은 스트림을 닫는 수 밖에 없다.  

NIO블로킹은 블로킹 스레드를 인터럽트로 빠져나올 수 있다는게 차이점이다. NIO 넌블로킹은 입출력 작업 준비가 완료된 채널만 선택해 작업 스레드를 붙여 처리할 수 있기 때문에 작업 스레드가 블로킹 되지 않는다.  

NIO 넌블로킹의 핵심 객체는

- 멀티플렉서
- 셀렉터

셀렉터는 여러 채널 중 준비 완료된 채널을 선택하는 방법을 제공해준다.  

## 1.2. 무엇을 선택해야 하는가

NIO의 장점은 불특정 다수의 연결이나 파일을 넌블로킹이나 비동기 처리가 가능하기 때문에 불필요하거나 과도한 스레드 생성을 피할 수 있다. 또한 운영체제의 버퍼(다이렉트 버퍼)  를 사용하기 때문에 성능 향상도 있다.  

그렇다면 NIO가 항상 유리할까? 아님. nodejs나 redis의 구조를 생각해보면 됨. 스레드가 처리하는 입출력이 시간을 오래 소모한다면 대기하는 작업 수가 늘어나서 오히려 불리할 수도 있다. 대용량 데이터 처리는 IO가 더 유리하다.  

IO가 유리한 파트

- 대용량 데이터 처리
- 순차적 처리

NIO가 유리한 파트

- 개별 처리가 간단한 요청들
- 비순차 처리
